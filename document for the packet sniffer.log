*********************************************************************************************
***********************************************************************

struct iphdr:

This C++ code defines a structure called iphdr which represents an IPv4 header.
IPv4 is one of the primary protocols used for communication over the internet.
Here's a detailed explanation of each member of the structure:

iph_ihl : 4, iph_ver : 4:

iph_ihl: Internet Header Length (IHL) specifies the length of the IP header. It's measured in 32-bit words.

iph_ver: Version of the IP protocol (IPv4 in this case).

Both fields are packed in the same byte. Each occupies 4 bits.

iph_tos: Type of Service (TOS) field indicates the quality of service desired for the datagram.

iph_len: Total Length of the IP packet (header + data), expressed in bytes.

iph_id: Identification field, used for uniquely identifying the fragments of a single IP datagram.

iph_offset: Fragment Offset field, which specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram.

iph_ttl: Time To Live (TTL) indicates the maximum time (in seconds or hops) that the packet is allowed to traverse the network.

iph_pro: Protocol field specifies the next layer protocol used in the data portion of the IP datagram. Common values include:

6: TCP (Transmission Control Protocol)

17: UDP (User Datagram Protocol)

There are many other values as well (ICMP, IGMP, etc.).

iph_che: Header Checksum for error-checking of the header only.

iph_sour[4]: Source IP address (4 bytes), represents the IP address of the sender.

iph_destip[4]: Destination IP address (4 bytes), represents the IP address of the recipient.

Usage
This structure used to parse IP headers in raw network packets.

***********************************************************************
*********************************************************************************************
***********************************************************************

void flag:

Function Definition
This C++ function named flag takes an unsigned short integer x as a parameter.
It checks various bits in the integer to determine which TCP flags are set and prints
corresponding flag names.

Usage
This function is useful in network programming, particularly for 
analyzing and debugging TCP packets. TCP (Transmission Control Protocol)
flags are used to control various aspects of the communication, and this function
helps identify which flags are set in a given packet.

***********************************************************************
*********************************************************************************************
***********************************************************************

struct tcphd

Structure Definition
This C++ code defines a structure called tcphd which represents a
TCP header. The Transmission Control Protocol (TCP) is one of the 
core protocols of the Internet protocol suite. Here's a detailed explanation 
of each member of the structure:

Member Explanation
source:

Source Port: The port number of the sending application.

des:

Destination Port: The port number of the receiving application.



seq:

Sequence Number: Used to keep track of the data being sent.



ack_seq:

Acknowledgment Number: If the ACK flag is set, this field contains the value of the next sequence number that the sender of the segment is expecting to receive. This acknowledges receipt of all prior bytes.



doff_res_flags:

Data Offset: Specifies the size of the TCP header in 32-bit words.

Reserved Bits: These are reserved for future use and should be set to zero.

Flags: Control flags, such as SYN, ACK, FIN, etc.

window:

Window Size: Specifies the size of the sender's receive window (i.e., buffer space available).

check:

Checksum: Used for error-checking of the header and data.

urg_ptr:

Urgent Pointer: If the URG flag is set, this field indicates the offset from the sequence 
number where the urgent data ends.

***********************************************************************
*********************************************************************************************
***********************************************************************

struct udphd

Structure Definition
This C++ code defines a structure called udphd which represents a UDP header. 
The User Datagram Protocol (UDP) is one of the core protocols of the 
Internet protocol suite. Here’s a detailed explanation of each member of 
the structure:

Member Explanation
sor:

Source Port: The port number of the sending application.

des:

Destination Port: The port number of the receiving application.

len:

Length: The length of the UDP header and data, expressed in bytes.

che:

Checksum: Used for error-checking of the header and data.

***********************************************************************
*********************************************************************************************
***********************************************************************

struct icmphd

Structure Definition
This C++ code defines a structure called icmphd which 
represents an ICMP header. The Internet Control Message 
Protocol (ICMP) is used for diagnostic and control purposes 
in IP networks.

Member Explanation
type:

ICMP Message Type: Specifies the type of the ICMP message. Different types have different meanings, such as:

0: Echo Reply

3: Destination Unreachable

8: Echo Request (Ping)

11: Time Exceeded

And many more.

code:

ICMP Message Code: Provides additional context for the ICMP message type. Each type can have multiple codes, which further specify the condition being reported.

che:

ICMP Checksum: Used for error-checking of the ICMP header and data.

id:

Identifier: Used for identifying the ICMP request/reply pair, especially in echo request/reply messages (Ping).

seq:

Sequence Number: Used in echo request/reply messages to match responses with requests.

***********************************************************************
*********************************************************************************************
***********************************************************************

iphdr* iP(const char* rec)

Function Definition
The function iphdr* iP(const char* rec) takes a pointer to a 
received data buffer (rec) and returns a pointer to an iphdr 
structure. This function is designed to parse and display the 
contents of an IP header from a raw network packet.

***********************************************************************
*********************************************************************************************
***********************************************************************

string getLocalIPAddress()

Function Definition
This C++ function, getLocalIPAddress, retrieves the local IPv4 address of 
the machine running the code. It uses the GetAdaptersInfo function from 
the Windows IP Helper API to obtain this information.

Member Explanation
Memory Allocation:

IP_ADAPTER_INFO adapterInfo[16]; allocates memory for up to 16 network adapters.

DWORD bufLen = sizeof(adapterInfo); sets the buffer length to the size of the allocated memory.

Getting Adapter Information:

GetAdaptersInfo(adapterInfo, &bufLen) == ERROR_SUCCESS checks if the function call succeeds in retrieving the adapter information.

Loop Through Adapters:

PIP_ADAPTER_INFO pAdapterInfo = adapterInfo; initializes a pointer to iterate through the adapter list.





while (pAdapterInfo) {} loops through each adapter.

Check for Valid IP Address:

if (pAdapterInfo->IpAddressList.IpAddress.String[0] != '0') {} checks if the first character of the IP address string is not '0'.

return pAdapterInfo->IpAddressList.IpAddress.String; returns the first valid IPv4 address found.

Return Statement:

return ""; returns an empty string if no valid IP address is found.

more details 

string getLocalIPAddress()

Type: Function

Purpose: Retrieves the local IPv4 address of the machine.

Returns: A string containing the local IP address, or an empty string if no IP address is found.

IP_ADAPTER_INFO adapterInfo[16];

Type: Array of IP_ADAPTER_INFO structures

Purpose: Allocates memory to store information about up to 16 network adapters.

IP_ADAPTER_INFO: A structure that contains information about a network adapter (part of the Windows IP Helper API).





DWORD bufLen = sizeof(adapterInfo);

Type: Variable of type DWORD (an unsigned 32-bit integer)

Purpose: Stores the size of the adapterInfo array in bytes.

if (GetAdaptersInfo(adapterInfo, &bufLen) == ERROR_SUCCESS)

Type: Function call

Purpose: Retrieves information about the network adapters. If successful, it returns ERROR_SUCCESS.

Parameters:

adapterInfo: A pointer to the buffer that receives the adapter information.

bufLen: A pointer to a variable that specifies the size of the buffer.




PIP_ADAPTER_INFO pAdapterInfo = adapterInfo;

Type: Pointer to IP_ADAPTER_INFO

Purpose: Points to the first element of the adapterInfo array, allowing iteration through the list of adapters.

{{The IP_ADAPTER_INFO structure contains information about a network adapter. This includes details such as the adapter's name, description, IP address, and more.}}

while (pAdapterInfo) {}

Type: Loop construct

Purpose: Iterates through the list of network adapters until pAdapterInfo is nullptr.





if (pAdapterInfo->IpAddressList.IpAddress.String[0] != '0') {}

Type: Conditional statement

Purpose: Checks if the first character of the IP address string is not '0', indicating a valid IP address.

pAdapterInfo->IpAddressList.IpAddress.String: An array of characters representing the IP address.

return pAdapterInfo->IpAddressList.IpAddress.String;

Type: Return statement

Purpose: Returns the first valid IPv4 address found as a string.

pAdapterInfo = pAdapterInfo->Next;

Type: Pointer assignment

Purpose: Moves the pointer to the next adapter in the list.

***********************************************************************
*********************************************************************************************
***********************************************************************

void catch_packet(SOCKET raw_soc)

Function Definition
The catch_packet function captures raw network packets using a specified socket. 
It processes the packets, extracts information from the IP header, and 
prints relevant details.



Member Explanation
void catch_packet(SOCKET raw_soc)

Type: Function

Purpose: Captures and processes raw network packets using the specified socket.

Parameters:

SOCKET raw_soc: A socket handle for capturing raw network packets.

char* recvbytes = new char[65536];

Type: Pointer to a dynamically allocated array of char

Purpose: Allocates memory to store received network packet data (up to 65,536 bytes).






int byteslen = 65536;

Type: Integer

Purpose: Specifies the length of the buffer for receiving network packets.

int timeout = 500000; 

Type: Integer

Purpose: Specifies the receive timeout value for the socket in milliseconds.









setsockopt(raw_soc, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));

Type: Function call

Purpose: Sets the socket receive timeout option to the specified value.

Parameters:

raw_soc: The socket handle.

SOL_SOCKET: Socket level option.

SO_RCVTIMEO: Option name to set the receive timeout.

(const char*)&timeout: Pointer to the timeout value.

sizeof(timeout): Size of the timeout value.











int number = 1;

Type: Integer

Purpose: Specifies the initial number of packets to capture.

for (int i = 0; i < number; i++) {}

Type: Loop construct

Purpose: Loops to capture the specified number of packets.














int byte_recived = recv(raw_soc, recvbytes, byteslen, 0);

Type: Function call

Purpose: Receives a packet from the socket and stores it in the buffer.

Parameters:

raw_soc: The socket handle.

recvbytes: Pointer to the buffer for storing received data.

byteslen: Length of the buffer.

0: Flags (no special flags in this case).

if (byte_recived == SOCKET_ERROR) {}

Type: Conditional statement

Purpose: Checks if an error occurred while receiving a packet.

Action: Prints the error code and breaks out of the loop.






else if (byte_recived > 0) {}

Type: Conditional statement

Purpose: Checks if a packet was received successfully.

Action: Prints the number of bytes received and processes the packet.

Processing the Packet:

iphdr* one = iP(recvbytes);: Parses the IP header from the received packet.

cout << endl << "*************************************************\n\n\n";: Prints a separator line for readability.

Prompt for More Packets:

if (i + 1 == number) {}: Checks if the current packet is the last one specified.

Prompt: Asks the user for the number of additional packets to capture.

cin >> number;: Reads the user's input.

if (number != -1) number = abs(number);: Ensures the number is positive, unless -1 (no more packets).

Memory Deallocation:

delete[] recvbytes;: Deallocates the dynamically allocated memory.

***********************************************************************
*********************************************************************************************
***********************************************************************

int process()

Function Definition
The process function initializes the Windows Sockets API (WinSock), creates a raw 
socket, binds it to the local IP address, and sets it up for packet sniffing. It 
captures and processes incoming network packets using the catch_packet function.


Member Explanation
WSADATA one:

Type: WSADATA structure

Purpose: Holds details of the Windows Sockets initialization.

if (WSAStartup(MAKEWORD(2, 2), &one) != 0):

Type: Function call

Purpose: Initializes the use of WinSock. Checks if the initialization fails.

Action: Prints an error message if initialization fails.





SOCKET rawsocket = socket(AF_INET, SOCK_RAW, IPPROTO_IP):

Type: Function call

Purpose: Creates a raw socket.

Parameters:

AF_INET: Address family (IPv4).

SOCK_RAW: Raw socket type.

IPPROTO_IP: IP protocol.

Action: Prints an error message if socket creation fails and cleans up resources.





sockaddr_in z:

Type: Structure

Purpose: Specifies the address to bind to the socket.

Members:

sin_family: Address family (IPv4).

sin_port: Port number (0 to select all, or a specific port like 443 for HTTPS).

sin_addr.s_addr: Local IP address.






string localIP = getLocalIPAddress():

Type: Function call

Purpose: Retrieves the local IPv4 address.

Action: Prints an error message and cleans up resources if the local IP address cannot be retrieved.




if (bind(rawsocket, (SOCKADDR*)&z, sizeof(z)) == SOCKET_ERROR):

Type: Function call

Purpose: Binds the raw socket to the local IP address.

Action: Prints an error message and cleans up resources if binding fails.






int yes = 1:

Type: Integer

Purpose: Used to enable IP header customization.

Action: Prints an error message and cleans up resources if setting the socket option fails.





if (setsockopt(rawsocket, IPPROTO_IP, IP_HDRINCL, (char*)&yes, sizeof(yes)) == SOCKET_ERROR):

Type: Function call

Purpose: Sets socket options to include the IP header.

Action: Prints an error message and cleans up resources if setting the socket option fails.

more details 
{Purpose
Sets the specified socket options. In this context, it enables or disables the inclusion of the IP header when sending packets on a raw socket.

Parameters
rawsocket:

Type: SOCKET

Purpose: The socket descriptor on which the option is set.

IPPROTO_IP:

Type: int

Purpose: The protocol level at which the option is defined. IPPROTO_IP indicates that the option is at the IP level.

IP_HDRINCL:

Type: int

Purpose: The option name. IP_HDRINCL specifies that the IP header is included in the data when sending packets. If set, the application must provide the IP header.

(char*)&yes:

Type: const char*

Purpose: A pointer to the option value. In this case, it points to the variable yes, which is set to 1 (enabling the option).

sizeof(yes):

Type: int

Purpose: The size of the option value. In this case, it is the size of the yes variable.

Action
Purpose: This call enables the inclusion of the IP header when sending packets on the rawsocket.

Error Handling: If the call fails (setsockopt returns SOCKET_ERROR), it prints an error message and cleans up resources (closes the socket and calls WSACleanup()).

Full Explanation
The function call setsockopt(rawsocket, IPPROTO_IP, IP_HDRINCL, (char*)&yes, sizeof(yes)) is used to configure the socket so that the application is responsible for constructing the IP header for the packets it sends. This is necessary when working with raw sockets that need full control over the packet, including the IP header.

If the function call fails (returns SOCKET_ERROR), it indicates that an error occurred while setting the socket option. In such a case, the program prints an error message using WSAGetLastError(), closes the raw socket using closesocket(rawsocket), and performs cleanup using WSACleanup() to release resources associated with WinSock.}

Benefits of Including the IP Header
Full Packet Visibility:

By enabling the IP_HDRINCL option, the application has full visibility and control over the entire IP packet, including the IP header. This allows the packet sniffer to capture and analyze all parts of the packet, not just the payload.









DWORD Dvalue = 1:

Type: DWORD

Purpose: Enables the packet sniffer to see any packet, even if it was not sent to this device.

Action: Prints an error message and cleans up resources if the WSAIoctl call fails.




if (WSAIoctl(rawsocket, SIO_RCVALL, &Dvalue, sizeof(Dvalue), NULL, 0, &bytesReturned, NULL, NULL) == SOCKET_ERROR):

Type: Function call

Purpose: Configures the socket to receive all packets.

Action: Prints an error message and cleans up resources if the WSAIoctl call fails.

more details
{Parameters
rawsocket:

Type: SOCKET

Purpose: The socket descriptor on which the operation is performed.

SIO_RCVALL:

Type: DWORD

Purpose: The control code for the operation. SIO_RCVALL enables the reception of all packets.

&Dvalue:

Type: LPVOID

Purpose: Pointer to the input buffer. Here, it points to the variable Dvalue, which is set to 1 to enable promiscuous mode.

sizeof(Dvalue):

Type: DWORD

Purpose: Size of the input buffer, which is the size of Dvalue.

NULL:

Type: LPVOID

Purpose: Pointer to the output buffer. Not used in this case, so it is NULL.

0:

Type: DWORD

Purpose: Size of the output buffer. Not used, so it is 0.

&bytesReturned:

Type: LPDWORD

Purpose: Pointer to a variable that receives the number of bytes returned. Here, it points to bytesReturned.

NULL:

Type: LPWSAOVERLAPPED

Purpose: Pointer to an OVERLAPPED structure for asynchronous operations. Not used, so it is NULL.

NULL:

Type: LPWSAOVERLAPPED_COMPLETION_ROUTINE

Purpose: Pointer to a completion routine called when the operation completes. Not used, so it is NULL.

Action
Purpose: This call configures the raw socket to receive all network packets. It enables promiscuous mode on the network interface.

Error Handling: If the call fails (returns SOCKET_ERROR), it prints an error message using WSAGetLastError(), closes the raw socket using closesocket(rawsocket), and calls WSACleanup() to release resources associated with WinSock.}

****The reason NULL can represent different types is because it acts as a generic null pointer constant that can be used for any pointer type****






catch_packet(rawsocket):

Type: Function call

Purpose: Captures and processes packets using the raw socket.



closesocket(rawsocket):

Type: Function call

Purpose: Closes the raw socket.



WSACleanup():

Type: Function call

Purpose: Cleans up the WinSock environment.